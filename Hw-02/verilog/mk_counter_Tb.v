//
// Generated by Bluespec Compiler, version 2024.07-22-g934465e3 (build 934465e3)
//
// On Fri Feb  7 15:35:11 EST 2025
//
//
// Ports:
// Name                         I/O  size props
// CLK                            I     1 clock
// RST_N                          I     1 reset
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mk_counter_Tb(CLK,
		     RST_N);
  input  CLK;
  input  RST_N;

  // register rg_counter_tb
  reg [31 : 0] rg_counter_tb;
  wire [31 : 0] rg_counter_tb$D_IN;
  wire rg_counter_tb$EN;

  // ports of submodule count
  wire count$EN_ma_start, count$ma_start_count_up;

  // rule scheduling signals
  wire CAN_FIRE_RL_rl_decrement,
       CAN_FIRE_RL_rl_finish,
       CAN_FIRE_RL_rl_start_count,
       WILL_FIRE_RL_rl_decrement,
       WILL_FIRE_RL_rl_finish,
       WILL_FIRE_RL_rl_start_count;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_rg_counter_tb$write_1__VAL_1;
  wire MUX_rg_counter_tb$write_1__SEL_1;

  // remaining internal signals
  wire rg_counter_tb_SLT_10___d2;

  // submodule count
  mk_counter count(.CLK(CLK),
		   .RST_N(RST_N),
		   .ma_start_count_up(count$ma_start_count_up),
		   .EN_ma_start(count$EN_ma_start),
		   .RDY_ma_start(),
		   .ma_stop(),
		   .RDY_ma_stop());

  // rule RL_rl_start_count
  assign CAN_FIRE_RL_rl_start_count = rg_counter_tb_SLT_10___d2 ;
  assign WILL_FIRE_RL_rl_start_count = rg_counter_tb_SLT_10___d2 ;

  // rule RL_rl_decrement
  assign CAN_FIRE_RL_rl_decrement =
	     !rg_counter_tb_SLT_10___d2 &&
	     (rg_counter_tb ^ 32'h80000000) < 32'h8000000F ;
  assign WILL_FIRE_RL_rl_decrement = CAN_FIRE_RL_rl_decrement ;

  // rule RL_rl_finish
  assign CAN_FIRE_RL_rl_finish = rg_counter_tb == 32'd15 ;
  assign WILL_FIRE_RL_rl_finish = CAN_FIRE_RL_rl_finish ;

  // inputs to muxes for submodule ports
  assign MUX_rg_counter_tb$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_decrement || WILL_FIRE_RL_rl_start_count ;
  assign MUX_rg_counter_tb$write_1__VAL_1 = rg_counter_tb + 32'd1 ;

  // register rg_counter_tb
  assign rg_counter_tb$D_IN =
	     MUX_rg_counter_tb$write_1__SEL_1 ?
	       MUX_rg_counter_tb$write_1__VAL_1 :
	       32'd0 ;
  assign rg_counter_tb$EN =
	     WILL_FIRE_RL_rl_decrement || WILL_FIRE_RL_rl_start_count ||
	     WILL_FIRE_RL_rl_finish ;

  // submodule count
  assign count$ma_start_count_up = !WILL_FIRE_RL_rl_decrement ;
  assign count$EN_ma_start = MUX_rg_counter_tb$write_1__SEL_1 ;

  // remaining internal signals
  assign rg_counter_tb_SLT_10___d2 =
	     (rg_counter_tb ^ 32'h80000000) < 32'h8000000A ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_counter_tb <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (rg_counter_tb$EN)
	  rg_counter_tb <= `BSV_ASSIGNMENT_DELAY rg_counter_tb$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    rg_counter_tb = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_start_count) $display("TB: count up");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_decrement) $display("TB:           count down");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_rl_finish) $display("TB:                    done");
    if (RST_N != `BSV_RESET_VALUE) if (WILL_FIRE_RL_rl_finish) $finish(32'd1);
  end
  // synopsys translate_on
endmodule  // mk_counter_Tb


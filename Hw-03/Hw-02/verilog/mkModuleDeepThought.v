//
// Generated by Bluespec Compiler, version 2024.07-22-g934465e3 (build 934465e3)
//
// On Wed Feb  5 20:13:15 EST 2025
//
//
// Ports:
// Name                         I/O  size props
// RDY_the_assign                 O     1 const
// the_answer                     O    32 reg
// RDY_the_answer                 O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// the_assign_x                   I    32 reg
// the_assign_y                   I    32 reg
// the_assign_z                   I    32 reg
// EN_the_assign                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkModuleDeepThought(CLK,
			   RST_N,

			   the_assign_x,
			   the_assign_y,
			   the_assign_z,
			   EN_the_assign,
			   RDY_the_assign,

			   the_answer,
			   RDY_the_answer);
  input  CLK;
  input  RST_N;

  // action method the_assign
  input  [31 : 0] the_assign_x;
  input  [31 : 0] the_assign_y;
  input  [31 : 0] the_assign_z;
  input  EN_the_assign;
  output RDY_the_assign;

  // value method the_answer
  output [31 : 0] the_answer;
  output RDY_the_answer;

  // signals for module outputs
  wire [31 : 0] the_answer;
  wire RDY_the_answer, RDY_the_assign;

  // register a
  reg [31 : 0] a;
  wire [31 : 0] a$D_IN;
  wire a$EN;

  // register b
  reg [31 : 0] b;
  wire [31 : 0] b$D_IN;
  wire b$EN;

  // register c
  reg [31 : 0] c;
  wire [31 : 0] c$D_IN;
  wire c$EN;

  // register d
  reg [31 : 0] d;
  wire [31 : 0] d$D_IN;
  wire d$EN;

  // rule scheduling signals
  wire CAN_FIRE_RL_compute_answer,
       CAN_FIRE_the_assign,
       WILL_FIRE_RL_compute_answer,
       WILL_FIRE_the_assign;

  // action method the_assign
  assign RDY_the_assign = 1'd1 ;
  assign CAN_FIRE_the_assign = 1'd1 ;
  assign WILL_FIRE_the_assign = EN_the_assign ;

  // value method the_answer
  assign the_answer = d ;
  assign RDY_the_answer = 1'd1 ;

  // rule RL_compute_answer
  assign CAN_FIRE_RL_compute_answer = 1'd1 ;
  assign WILL_FIRE_RL_compute_answer = 1'd1 ;

  // register a
  assign a$D_IN = the_assign_x ;
  assign a$EN = EN_the_assign ;

  // register b
  assign b$D_IN = the_assign_y ;
  assign b$EN = EN_the_assign ;

  // register c
  assign c$D_IN = the_assign_z ;
  assign c$EN = EN_the_assign ;

  // register d
  assign d$D_IN = a + b + c ;
  assign d$EN = 1'd1 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        a <= `BSV_ASSIGNMENT_DELAY 32'd0;
	b <= `BSV_ASSIGNMENT_DELAY 32'd0;
	c <= `BSV_ASSIGNMENT_DELAY 32'd0;
	d <= `BSV_ASSIGNMENT_DELAY 32'd0;
      end
    else
      begin
        if (a$EN) a <= `BSV_ASSIGNMENT_DELAY a$D_IN;
	if (b$EN) b <= `BSV_ASSIGNMENT_DELAY b$D_IN;
	if (c$EN) c <= `BSV_ASSIGNMENT_DELAY c$D_IN;
	if (d$EN) d <= `BSV_ASSIGNMENT_DELAY d$D_IN;
      end
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    a = 32'hAAAAAAAA;
    b = 32'hAAAAAAAA;
    c = 32'hAAAAAAAA;
    d = 32'hAAAAAAAA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      $display("Firing with a=%d, b= %d, c= %d",
	       $signed(a),
	       $signed(b),
	       $signed(c));
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_the_assign)
	$display("After firing the values are  a=%d, b= %d, c= %d",
		 $signed(a),
		 $signed(b),
		 $signed(c));
  end
  // synopsys translate_on
endmodule  // mkModuleDeepThought

